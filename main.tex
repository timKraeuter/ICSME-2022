\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
% My packages start
\usepackage{hyperref}
\usepackage{glossaries}

\newacronym{jive}{JIVE}{Java Interactive Visualization Environment}
\newacronym{uml}{UML}{Unified Modeling Language}
\newacronym{ide}{IDE}{Integrated Development Environment}
\newacronym{api}{API}{Application Programming Interface}
\newcommand{\intellij}{IntelliJ IDEA}
% My packages end

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{The Visual Debugger Tool\\
{}
\thanks{}
}

\author{\IEEEauthorblockN{
% 1\textsuperscript{st}
Tim Kräuter}
\IEEEauthorblockA{
% \textit{Department of Computer science,} \\
% \textit{Electrical engineering and Mathematical sciences} \\
\textit{Høgskulen på Vestlandet}\\
Bergen, Norway \\
tkra@hvl.no}
% \and
% \IEEEauthorblockN{
% % 2\textsuperscript{nd}
% Adrian Rutle}
% \IEEEauthorblockA{
% % \textit{Department of Computer science,} \\
% % \textit{Electrical engineering and Mathematical sciences} \\
% \textit{Høgskulen på Vestlandet}\\
% Bergen, Norway \\
% aru@hvl.no}
% \and
% \IEEEauthorblockN{
% % 3\textsuperscript{rd}
% Harald König}
% \IEEEauthorblockA{
% % \textit{Department of Computer science,} \\
% % \textit{Electrical engineering and Mathematical sciences} \\
% \textit{University of Applied Sciences, FHDW}\\
% Hannover, Germany \\
% harald.koenig@fhdw.de}
% \and
% \IEEEauthorblockN{
% % 4\textsuperscript{th}
% Yngve Lamo}
% \IEEEauthorblockA{
% % \textit{Department of Computer science,} \\
% % \textit{Electrical engineering and Mathematical sciences} \\
% \textit{Høgskulen på Vestlandet}\\
% Bergen, Norway \\
% yla@hvl.no}
}

\maketitle

% TODO: 3-5 Minute screen cast showcasing the tool (Put it on youtube, Maybe with my developer account). Also link that one on the plugin page.
% 4 pages + 1 page of only references!

\begin{abstract}
\emph{Debugging} is an important activity in software development to understand control- and data flow and find programming errors.
Traditionally program information was visualized in a textual manner during debugging.
However, we have developed a novel tool for visualizing program information as object diagrams, integrated as a plugin into the popular Java development environment \intellij{}.
\end{abstract}

\begin{IEEEkeywords}
Debugging, Visual Debugging, Visual Debugger, Software Visualization, IntelliJ IDEA Plugin
\end{IEEEkeywords}

\section{Introduction}
Debugging is an essential part of software maintenance and evolution since it allows a software developer to halt the execution of a program at any point and to inspect the current program state.
Traditionally program information is represented in a textual manner during debugging.
Moreover, software developers spend between 35 and 50 percent of their time validating and debugging software \cite{odellDebuggingMindsetUnderstanding2017}.
However, a graphical representation might allow for a faster and better understanding of specific scenarios.
Thus, research to visualize program information graphically during debugging has started, motivated by possible reductions in the time spent during debugging. 

We have developed an \intellij{} plugin\footnote{The plugin can be found at \url{https://plugins.jetbrains.com/plugin/16851-visual-debugger}.}, which visualizes the program state as an object diagram for better program comprehension.
% Explain the plugin shortly and link to a youtube video. 

\section{Related work} \label{sec:relatedWork}
% JIVE is comprehensive but the downside is that it offers too much functionality!
\textit{\gls*{jive}}\footnote{\url{https://cse.buffalo.edu/jive/}} is a plugin for the Eclipse \gls*{ide} \cite{czyzDeclarativeVisualDebugging2007,k.p.FiniteStateModel2021}.
It provides interactive Java program execution visualization at different levels of granularity.
The program state is visualized as a \gls*{uml} object diagram, while the call stack is represented as a \gls*{uml} sequence diagram.

% Java Visualizer
A plugin called \textit{Java Visualizer}\footnote{\url{https://plugins.jetbrains.com/plugin/11512-java-visualizer}} has been developed for the \intellij{}.
It visualizes the call stack and objects contained in the Java heap as a box-and-pointer diagram during a debugging session.
However, even in simple scenarios, the visualized call stacks are long since all objects from the Java heap are visualized and not only the variables in the debugging scope.
This leads to much noise in the visualization, especially if one is only interested in the current objects, i.e., the current system state.
Nevertheless, the additional information can be helpful when the program flow must be understood in detail. 

% Debugging for distributed applications
In \cite{kochGraphicalDebuggingDistributed2015}, the authors describe a tool to debug distributed applications.
It can connect to multiple Java virtual machines and show the retrieved objects either separately in an object diagram or combine the same objects from different JVMs using object identifiers or other properties.
The tool is also tightly integrated with the Eclipse \gls*{ide}.
However, we could not find and test the tool by ourselves.

\textit{JAVAVIS} is a standalone tool to help students understand what happens during program execution in Java \cite{oechsleJAVAVISAutomaticProgram2002}.
It makes use of object- and sequence diagrams to represent program behavior.

% Might not need this paragraph is space is limited.
The idea to visualize textual structures during software development has also been used in the BlueJ \gls*{ide} designed for teaching object orientation \cite{kollingBlueJSystemIts2003,kollingObjectorientedProgramDevelopment1996}.
It uses a class diagram visualizing the application structure.
One can interact with classes to create objects which are then visualized in an object diagram style.

\section{Tool architecture}
Our tool consists of the plugin and the visualization component.
First, the plugin components integrate with \intellij{} by automatically hooking into any started debugging process of the \gls*{ide}.
The goal of the plugin component is to obtain the current debugging information from \intellij{} and pass it on to the visualization component.
In addition, the plugin component offers a method to load detailed information for individual objects in the current debugging scope.

Second, the visualization component represents the debugging information as an object diagram to ease program understanding.
Moreover, it allows interaction to load additional debugging information for the currently shown objects.
The visualization component is \emph{browser-based} and relies on a fixed \emph{Debugging \gls*{api}}.
Consequently, it can be re-used as a front end for visual debugging tools integrated into any \gls*{ide}.

% Explain the Debugging API
The Debugging \gls*{api}\footnote{The Debugging \gls*{api} is described in full detail at \url{https://github.com/timKraeuter/VisualDebugger/tree/master/documentation\#debugging-api}.} is based on \emph{WebSocket} to achieve live updates about changes in the debugging information, see \autoref{fig:api}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.48\textwidth]{images/architecture.pdf}
    \caption{Communication through the Debugger API}
    \label{fig:api}
\end{figure}

Initially, a browser connects to the WebSocket server hosting the Debugger \gls*{api} included in our Visual Debugger plugin.
Afterward, the browser is updated live about new debugging information due to debugging actions in the \gls*{ide}, such as hitting a breakpoint or jumping to the next line in the source code.
In addition, the visualization component allows a user to interact with the visualization to load all direct children and attributes of any shown object.

\section{Conclusion}

\section*{Acknowledgment}

% TODO: check References one by one at the end!
\bibliographystyle{IEEEtran}
\bibliography{bib}

\end{document}
