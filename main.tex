\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
% My packages start
\usepackage{hyperref}
\usepackage{glossaries}

\newacronym{jive}{JIVE}{Java Interactive Visualization Environment}
\newacronym{uml}{UML}{Unified Modeling Language}
\newcommand{\intellij}{IntelliJ IDEA}
% My packages end

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{The Visual Debugger Tool\\
{}
\thanks{}
}

\author{\IEEEauthorblockN{
% 1\textsuperscript{st}
Tim Kräuter}
\IEEEauthorblockA{
% \textit{Department of Computer science,} \\
% \textit{Electrical engineering and Mathematical sciences} \\
\textit{Høgskulen på Vestlandet}\\
Bergen, Norway \\
tkra@hvl.no}
\and
\IEEEauthorblockN{
% 2\textsuperscript{nd}
Adrian Rutle}
\IEEEauthorblockA{
% \textit{Department of Computer science,} \\
% \textit{Electrical engineering and Mathematical sciences} \\
\textit{Høgskulen på Vestlandet}\\
Bergen, Norway \\
aru@hvl.no}
\and
\IEEEauthorblockN{
% 3\textsuperscript{rd}
Harald König}
\IEEEauthorblockA{
% \textit{Department of Computer science,} \\
% \textit{Electrical engineering and Mathematical sciences} \\
\textit{University of Applied Sciences, FHDW}\\
Hannover, Germany \\
harald.koenig@fhdw.de}
\and
\IEEEauthorblockN{
% 4\textsuperscript{th}
Yngve Lamo}
\IEEEauthorblockA{
% \textit{Department of Computer science,} \\
% \textit{Electrical engineering and Mathematical sciences} \\
\textit{Høgskulen på Vestlandet}\\
Bergen, Norway \\
yla@hvl.no}
}

\maketitle

% TODO: 3-5 Minute screen cast showcasing the tool (Put it on youtube, Maybe with my developer account). Also link that one on the plugin page.

\begin{abstract}
TBD
\end{abstract}

\begin{IEEEkeywords}
Debugging, Visual Debugging, Visual Debugger, Software Visualization, IntelliJ IDEA Plugin
\end{IEEEkeywords}

\section{Introduction}
We developed a novel software maintenance and evolution tool\footnote{\url{https://plugins.jetbrains.com/plugin/16851-visual-debugger}}.

\section{Related work} \label{sec:relatedWork}
% JIVE is comprehensive but the downside is that it offers too much functionality!
\textit{\gls*{jive}}\footnote{\url{https://cse.buffalo.edu/jive/}} is a plugin for the Eclipse IDE \cite{czyzDeclarativeVisualDebugging2007,k.p.FiniteStateModel2021}.
It provides interactive Java program execution visualization at different levels of granularity.
The program state is visualized as a \gls*{uml} object diagram, while the call stack is represented as a \gls*{uml} sequence diagram.
Furthermore, the plugin offers to filter and employs methods for a compact presentation of repeating elements in \gls*{uml} diagrams \cite{jayaramanCompactVisualizationJava2017}.
A complete list of functionality and associated publications can be found on the website mentioned above.
Unfortunately, we could not find the objects in \autoref{fig:debugging_variables} in the generated object diagram when debugging the corresponding test case using Eclipse IDE version \textit{2020-12}.

% Java Visualizer
A plugin called \textit{Java Visualizer}\footnote{\url{https://plugins.jetbrains.com/plugin/11512-java-visualizer}} has been developed for the \intellij{}.
It visualizes the call stack and objects contained in the Java heap during a debugging session.
However, it uses a box-and-pointer diagram as visualization and not an object diagram as our plugin.
The plugin installation and use were straightforward, and we did not run into any errors when testing the debugging using the example from \autoref{fig:debugging_variables} in \intellij{} version \textit{2021.1.1}.
Besides the objects, it also visualizes the call stack, which can be helpful when analyzing program flow.
However, even in simple scenarios, the visualized call stacks are long since all objects from the Java heap are visualized and not only the variables in the debugging scope.
This leads to much noise in the visualization, especially if one is only interested in the current objects, i.e., the current system state.
However, the additional information can be helpful when the program flow must be understood in detail. 

% Debugging for distributed applications
In \cite{kochGraphicalDebuggingDistributed2015}, the authors describe a tool to debug distributed applications.
It can connect to multiple Java virtual machines and show the retrieved objects either separately in an object diagram or even combining the same objects from different JVMs using object identifiers or other properties.
The tool is also tightly integrated with the Eclipse IDE.
However, we were not able to test the tool by ourselves.

\textit{JAVAVIS} is a standalone tool to help students understand what happens during program execution in Java \cite{oechsleJAVAVISAutomaticProgram2002}.
It makes use of object- and sequence diagrams to represent program behavior.

The idea to visualize textual structures during software development has also been used in the BlueJ IDE designed for teaching object orientation \cite{kollingBlueJSystemIts2003,kollingObjectorientedProgramDevelopment1996}.
It uses a class diagram visualizing the application structure.
One can interact with classes to create objects which are then visualized in an object diagram style.
Afterward, method calls can be executed through the user interface on the created objects.
However, objects are shown in isolation.
Links between objects are not visualized.
BlueJ focuses more on program development, whereas our plugin focuses on program execution.

% There is a plugin called \textit{Debug Visualizer}\footnote{https://marketplace.visualstudio.com/items?itemName=hediet.debug-visualizer} for the Visual Studio Code IDE.
% Visual Studio Code is mainly used for web development.
% It focuses on visualizing different data structures, such as graphs, tables (maps), trees, and more.
% The plugin aims not to visualize the whole state of a system but to inspect one data structure at a time and understand how it changes during debugging.

\section{Tool architecture}
General separation in UI and Debugging info provider.

\section{Conclusion}

\section*{Acknowledgment}

% TODO: checc References 1 by one at the end!
\bibliographystyle{IEEEtran}
\bibliography{bib}

\end{document}
